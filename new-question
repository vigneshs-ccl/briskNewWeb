import { CommonModule } from "@angular/common";
import {
  Component,
  EventEmitter,
  Input,
  OnInit,
  Output,
  SimpleChanges,
} from "@angular/core";
import {
  ReactiveFormsModule,
  FormBuilder,
  FormGroup,
  FormArray,
  Validators,
} from "@angular/forms";

// adjust these import paths to match your project structure
import { CommonDialogComponent } from "../../../common-dialog/common-dialog.component";
import { CustomDropdownComponent } from "../../../custom-dropdown/custom-dropdown.component";
import { createGuid } from "@app/utills/helper";
import { ConnectivityService } from "@app/connectivity.service";
import { ProjectDetailsService } from "@app/services/project-details.service";
import { Survey } from "@app/interfaces/survey";
import { QuestionsList } from "@app/interfaces/questionsList";
import { Subject, takeUntil } from "rxjs";
import { QuestionType } from "@app/interfaces/question";
import { TextEditorComponent } from "@app/components/text-editor/text-editor.component";
import { ToastService } from "@app/services/toast.service";
import { ButtonModule } from "primeng/button";
import { CheckboxModule } from "primeng/checkbox";
import { FormsModule } from "@angular/forms";
import { RadioButtonModule } from "primeng/radiobutton";
import { CustomCheckboxComponent } from "@app/components/custom-checkbox/custom-checkbox.component";
@Component({
  selector: "app-create-questions-dialog",
  standalone: true,
  imports: [
    CommonModule,
    ReactiveFormsModule,
    CommonDialogComponent,
    CustomDropdownComponent,
    TextEditorComponent,
    CommonModule,
    ButtonModule,
    CheckboxModule,
    FormsModule,
    RadioButtonModule,
    CustomCheckboxComponent,
  ],
  templateUrl: "./create-questions-dialog.component.html",
  styleUrls: ["./create-questions-dialog.component.scss"],
})
export class CreateQuestionsDialogComponent implements OnInit {
  @Input() visible = false;
  @Input() questionModel: any = null; // optional: existing question when editing
  @Output() close = new EventEmitter<void>();
  @Output() questionSaved = new EventEmitter<any>();
  guid = createGuid();
  questionForm!: FormGroup | any;
  @Input() section: any;
  @Input() selectedQuestions: any;
  public survey!: Survey;
  private destroy$ = new Subject<void>();
  question: any;
  QyuestionTypes: QuestionType[] = [];
  loading: boolean = false;
  constructor(
    private projectService: ConnectivityService,
    private projectDetailsService: ProjectDetailsService,
    private toastService: ToastService,
    private fb: FormBuilder
  ) {
    this.projectDetailsService.projectDetails$
      .pipe(takeUntil(this.destroy$))
      .subscribe((data) => {
        this.survey = data;
      });
  }

  // icon system (shared)
  iconNames: string[] = [
    "document", // KeepPosition
    "unlock", // Other
    "shield-cross", // NotTerminate
    "shield-tick", // Terminate
    "text-block", // Punch
    "close-circle", // remove
  ];

  // mapping for property keys (index aligned with iconNames)
  iconKeysOrder: (string | null)[] = [
    "Punch",
    "KeepPosition",
    "NotTerminate",
    "Terminate",
    "Other",
    null,
  ];

  hoveredIconIndex: (number | null)[] = [];
  activeIconIndex: boolean[][] = [];

  // simple list of question types for dropdown (use label because template expects 'label')
  questionTypes = [
    { id: 1, label: "Single Response" },
    { id: 2, label: "Multiple Response" },
    { id: 3, label: "Open End List" },
    { id: 4, label: "Numeric List" },
    { id: 5, label: "Rank" },
    { id: 6, label: "Grid Single" },
    { id: 7, label: "Grid Multiple" },
  ];
  responseOrders = [
    { name: "InOrder", value: "InOrder" },
    { name: "Randomize", value: "Randomize" },
    { name: "Rotate", value: "Rotate" },
    { name: "Flip", value: "Flip" },
    { name: "Alphabetic", value: "Alphabetic" },
  ];

  ngOnInit(): void {
    this.questionForm = this.fb.group({
      number: ["", Validators.required],
      type: [null, Validators.required],
      text: [""],
      instructions: [""],
      validation: [""],
      responseOrder: [null],
      responses: this.fb.array([]),
    });
    // if an existing question model is provided, patch it
    if (this.selectedQuestions) {
      console.log(
        "Patching form with existing question:",
        this.selectedQuestions
      );
      this.patchForm(this.selectedQuestions);
    } else {
      // start with one response by default
      this.addResponse();
    }
  }

  ngOnChanges(changes: SimpleChanges) {
    if (
      changes["selectedQuestions"] &&
      changes["selectedQuestions"].currentValue
    ) {
      console.log("selectedQuestions changed:", this.selectedQuestions);
      this.patchForm(this.selectedQuestions);
    } else {
      this.resetForm();
    }
  }
  // shorthand getter
  get responses(): FormArray {
    return this.questionForm.get("responses") as FormArray;
  }

  // add a response formGroup (with properties group)
  addResponse(): void {
    const rg = this.fb.group({
      responseText: ["", Validators.required],
      properties: this.fb.group({
        KeepPosition: [false],
        Other: [false],
        NotTerminate: [false],
        Terminate: [false],
        Punch: [false],
      }),
    });

    this.responses.push(rg);

    const newIndex = this.responses.length - 1;
    this.hoveredIconIndex[newIndex] = null;
    this.activeIconIndex[newIndex] = Array(this.iconNames.length).fill(false);
  }

  removeResponse(index: number): void {
    if (index < 0 || index >= this.responses.length) return;
    this.responses.removeAt(index);
    this.hoveredIconIndex.splice(index, 1);
    this.activeIconIndex.splice(index, 1);
  }

  // UI hover handlers
  setHovered(responseIndex: number, iconIndex: number | null): void {
    this.hoveredIconIndex[responseIndex] = iconIndex;
  }

  // toggle property or handle remove icon
  setActiveStatus(responseIndex: number, iconIndex: number): void {
    const icon = this.iconNames[iconIndex];
    const key = this.iconKeysOrder[iconIndex];
    // remove icon: just remove the response
    if (icon === "close-circle") {
      this.removeResponse(responseIndex);
      return;
    }

    if (!key) return;

    const responseGroup = this.responses.at(responseIndex) as FormGroup;
    const propCtrl = responseGroup.get(["properties", key]);
    if (!propCtrl) return;

    const newVal = !propCtrl.value;
    propCtrl.setValue(newVal);
    // keep UI active array in sync
    this.activeIconIndex[responseIndex][iconIndex] = newVal;
  }

  // image src builder: adds '-clr' suffix when hovered OR active
  getIconSrc(iconIndex: number, responseIndex: number): string {
    const icon = this.iconNames[iconIndex];
    if (icon === "close-circle") return `assets/images/projects/${icon}.svg`;
    const isHovered = this.hoveredIconIndex[responseIndex] === iconIndex;
    const isActive = this.activeIconIndex[responseIndex][iconIndex];
    const suffix = isHovered || isActive ? "-clr" : "";
    return `assets/images/projects/${icon}${suffix}.svg`;
  }

  getIconClass(
    icon: string,
    hoveredIdx: number | null,
    active: boolean,
    iconIndex: number
  ): string {
    if (icon === "close-circle") return "icon-close-circle";
    const hover = hoveredIdx === iconIndex ? `icon-${icon}-hover` : "";
    const activeClass = active ? `icon-${icon}-active` : "";
    return `icon-${icon} ${hover} ${activeClass}`;
  }

  // patch form with existing question (for edit)
  patchForm(question: any): void {
    // patch main fields
    this.questionForm.patchValue({
      number: question.questionNumber || "",
      type: question.questionType || null,
      text: question.questionInnerText || question.questionText || "",
      instructions: question.questionInstruction || "",
      validation: question.validation || "",
      responseOrder: question.properties?.AnswerlistOrder || "InOrder",
    });

    // clear existing responses
    while (this.responses.length) this.responses.removeAt(0);
    this.hoveredIconIndex = [];
    this.activeIconIndex = [];

    // patch responses
    (question.responses || []).forEach((r: any) => {
      const rg = this.fb.group({
        responseText: [
          r.responseInnerText || r.responseText || "",
          Validators.required,
        ],
        properties: this.fb.group({
          KeepPosition: [!!r.properties?.KeepPosition],
          Other: [!!r.properties?.Other],
          NotTerminate: [!!r.properties?.NotTerminate],
          Terminate: [!!r.properties?.Terminate],
          Punch: [!!r.properties?.Punch],
        }),
        responseID: [r.responseID], // keep original ID for edit
      });

      this.responses.push(rg);

      const idx = this.responses.length - 1;
      this.hoveredIconIndex[idx] = null;
      this.activeIconIndex[idx] = Array(this.iconNames.length).fill(false);

      // set active icons based on properties
      const props = r.properties || {};
      this.iconKeysOrder.forEach((k, iconIdx) => {
        if (k && props[k]) this.activeIconIndex[idx][iconIdx] = true;
      });
    });

    // if no responses, add one empty
    if (!question.responses || !question.responses.length) this.addResponse();
  }
  onSave(): void {
    if (this.questionForm.invalid) {
      this.questionForm.markAllAsTouched();
      return;
    }
    this.loading = true;
    const formValue = this.questionForm.value;

    const payload = {
      questionID: this.selectedQuestions?.questionID || this.guid,
      sectionID: this.section?.sectionID || "",
      surveyID: this.section?.surveyID || "",
      questionNumber: formValue.number,
      questionVariable: formValue.number,
      questionOrder: this.selectedQuestions?.questionOrder || "1",
      questionText: formValue.text || "New Question",
      questionInnerText: formValue.text || "New Question",
      questionTypeId: null,
      questionType: formValue.type,
      questionInstruction: formValue.instructions || "",
      questionTextSurveyProgramming: "",
      questionTextDataProcessing: "",
      outputStyle: null,
      startLoc: "",
      endLoc: "",
      ratingScale: "",
      reverse: "",
      createdBy: null,
      createdDate: null,
      modifiedBy: null,
      modifiedDate: null,
      responses: formValue.responses.map((r: any, index: number) => ({
        responseID: r.responseID || this.guid,
        surveyID: this.section?.surveyID || "",
        responseText: r.responseText || "",
        responseInnerText: r.responseText || "",
        responseInitialOrder: index + 1,
        responseOrder: index + 1,
        responseCode: (index + 1).toString(),
        responseTextRight: "",
        responseInstruction: "",
        instruction: "",
        processedComments: "",
        processedCommentsDecipher: "",
        processedCommentsDooblo: "",
        processedCommentsDimensions: "",
        questionID: this.selectedQuestions?.questionID || this.guid,
        questionTypeId: null,
        outputStyle: null,
        responseTextSurveyProgramming: null,
        responseTextDataProcessing: null,
        responseProcessedInstruction: null,
        createdBy: null,
        createdDate: null,
        modifiedBy: null,
        modifiedDate: null,
        start: null,
        end: null,
        outputData: null,
        predefinedList: null,
        comments: null,
        questionType: null,
        questionVariable: formValue.number,
        properties: {
          KeepPosition: r.properties?.KeepPosition || false,
          Punch: r.properties?.Punch || false,
          Other: r.properties?.Other || false,
          Terminate: r.properties?.Terminate || false,
          NotTerminate: r.properties?.NotTerminate || false,
          Code: false,
        },
      })),
      questionResponses: null,
      attributes: [],
      questions: [],
      innerStartIndex: null,
      comments: null,
      processedComments: "FieldWidth='1' ",
      processedCommentsDecipher: "",
      processedCommentsDooblo: 'RangeMin="1" RangeMax="1" ',
      processedCommentsDimensions: "",
      questionMask: "",
      precodeMask: "",
      columnMask: "",
      scalePrecodeMask: "",
      rowMask: "",
      validation: "",
      outputData: null,
      properties: {
        AnswerlistOrder: formValue.responseOrder || "InOrder",
        Dropdown: false,
      },
    };

    this.question = payload;

    if (!this.section.questions) this.section.questions = [];
    const existingQuestionIndex = this.section.questions.findIndex(
      (q: { questionID: any }) => q.questionID === this.question.questionID
    );

    if (existingQuestionIndex > -1) {
      // Update existing question
      this.section.questions[existingQuestionIndex] = { ...this.question };
    } else {
      // Add new question
      this.section.questions.push({ ...this.question });
    }

    // Add/update section in the survey
    const sectionIndex = this.survey.sections.findIndex(
      (s) => s.sectionID === this.section.sectionID
    );

    if (sectionIndex > -1) {
      this.survey.sections[sectionIndex] = this.section;
    } else {
      this.survey.sections.push(this.section);
    }

    this.projectService.saveSurvey(this.survey).subscribe({
      next: (res) => {
        console.log("Survey saved successfully", res);
        this.toastService.notify(
          "success",
          "Success",
          `Question ${
            this.selectedQuestions ? "Edited" : "Created"
          } Successfully!`,
          "purple-500",
          false
        );
        this.questionSaved.emit(this.survey);
        this.loading = false;
        this.onClose();
        if (!this.selectedQuestions) {
          this.resetForm();
        }
      },
      error: (err) => {
        console.error("Error saving survey", err);
        this.loading = false;
      },
    });
  }

  onClose(): void {
    this.visible = false;
    this.close.emit();
  }

  resetForm(): void {
    // reset main form fields
    this.questionForm.reset({
      number: "",
      type: null,
    });

    // clear all responses
    while (this.responses.length) {
      this.responses.removeAt(0);
    }

    // reset icon states
    this.hoveredIconIndex = [];
    this.activeIconIndex = [];

    // add one empty response
    this.addResponse();

    // clear existing model
    this.questionModel = null;

    // generate fresh GUID
    this.guid = createGuid();
  }

  // Add masking / filter section
  createMaskingDialogVisible: boolean = false;
  currentQuestion: QuestionsList | null = null;
  step: "list" | "options" | "review" = "list";
  selectionMode: "selected" | "unselected" | "custom" = "selected";
  backupSelectedIds: number[] = [];
  // backups for additional fields so cancel restores everything
  backupConditionType: "if" | "or" | "and" | undefined;
  backupComparator: "is" | "isnot" | "sum" | undefined;
  backupOptionOperators: { [id: number]: "or" | "and" } = {};
  operationsList = [
    { label: "Or", value: "or" },
    { label: "And", value: "and" },
  ];
  viewOnly: boolean = false;
  // loading: boolean = false;

  questions: QuestionsList[] = [
    {
      Qno: 1,
      icon: "assets/images/questions/task.png",
      question:
        "Does your household high-speed home Internet service (Fiber, Cable, DSL, 5G Home Internet, etc.)?",
      options: [
        { id: 1, option: "Purchased a vehicle" },
        { id: 2, option: "Bought a home" },
        { id: 3, option: "Changed my home Internet service provider" },
        { id: 4, option: "Went on a vacation" },
        { id: 5, option: "Changed my job or place of employment" },
      ],
      selectedOptionIds: [],
      // initialize defaults for new fields
      conditionType: "if",
      comparator: "is",
      optionOperators: {},
    },
    // ... other questions (same as your original)
    {
      Qno: 2,
      icon: "assets/images/questions/task.png",
      question:
        "Which best describes your role in the decision-making process for selecting an Internet service provider?",
      options: [
        { id: 1, option: "Purchased a vehicle" },
        { id: 2, option: "Bought a home" },
        { id: 3, option: "Changed my home Internet service provider" },
        { id: 4, option: "Went on a vacation" },
        { id: 5, option: "Changed my job or place of employment" },
      ],
      selectedOptionIds: [],
      conditionType: "or",
      comparator: "is",
      optionOperators: {},
    },
    {
      Qno: 3,
      icon: "assets/images/questions/task.png",
      question:
        "Does your household high-speed home Internet service (Fiber, Cable, DSL, 5G Home Internet, etc.)?",
      options: [
        { id: 1, option: "Purchased a vehicle" },
        { id: 2, option: "Bought a home" },
        { id: 3, option: "Changed my home Internet service provider" },
        { id: 4, option: "Went on a vacation" },
        { id: 5, option: "Changed my job or place of employment" },
      ],
      selectedOptionIds: [],
      conditionType: "or",
      comparator: "is",
      optionOperators: {},
    },
    {
      Qno: 4,
      icon: "assets/images/questions/task.png",
      question:
        "Does your household high-speed home Internet service (Fiber, Cable, DSL, 5G Home Internet, etc.)?",
      options: [
        { id: 1, option: "Purchased a vehicle" },
        { id: 2, option: "Bought a home" },
        { id: 3, option: "Changed my home Internet service provider" },
        { id: 4, option: "Went on a vacation" },
        { id: 5, option: "Changed my job or place of employment" },
      ],
      selectedOptionIds: [],
      conditionType: "or",
      comparator: "is",
      optionOperators: {},
    },
    {
      Qno: 5,
      icon: "assets/images/questions/task.png",
      question:
        "Which best describes your role in the decision-making process for selecting an Internet service provider?",
      options: [
        { id: 1, option: "Purchased a vehicle" },
        { id: 2, option: "Bought a home" },
        { id: 3, option: "Changed my home Internet service provider" },
        { id: 4, option: "Went on a vacation" },
        { id: 5, option: "Changed my job or place of employment" },
      ],
      selectedOptionIds: [],
      conditionType: "or",
      comparator: "is",
      optionOperators: {},
    },
    {
      Qno: 6,
      icon: "assets/images/questions/task.png",
      question:
        "Does your household high-speed home Internet service (Fiber, Cable, DSL, 5G Home Internet, etc.)?",
      options: [
        { id: 1, option: "Purchased a vehicle" },
        { id: 2, option: "Bought a home" },
        { id: 3, option: "Changed my home Internet service provider" },
        { id: 4, option: "Went on a vacation" },
        { id: 5, option: "Changed my job or place of employment" },
      ],
      selectedOptionIds: [],
      conditionType: "or",
      comparator: "is",
      optionOperators: {},
    },
  ];

  // opening dialog box
  openMaskDialog(showReview: boolean = false): void {
    this.createMaskingDialogVisible = true;

    if (showReview) {
      // open directly to review step
      this.step = "review";
      this.viewOnly = true;
    } else {
      // normal add mask flow
      this.step = "list";
      this.viewOnly = false;
    }
  }

  // closing dialog box
  closeMaskDialog(): void {
    this.createMaskingDialogVisible = false;
    this.step = "list";
  }

  // openOption section after question clicked
  openOptions(question: QuestionsList) {
    if (question.disabled) return;

    this.currentQuestion = question;
    this.step = "options";
    // backup current selection to restore on cancel
    this.backupSelectedIds = [...(question.selectedOptionIds || [])];

    // backup additional fields
    this.backupConditionType = question.conditionType;
    this.backupComparator = question.comparator;
    this.backupOptionOperators = { ...(question.optionOperators || {}) };

    // ensure defaults exist
    if (!question.optionOperators) question.optionOperators = {};
    if (!question.comparator) question.comparator = "is";
    // first question must be 'if'
    if (question.Qno === 1) question.conditionType = "if";
    else if (!question.conditionType) question.conditionType = "or";
  }

  // sets the seleted/unselected mode for selection mode.
  setSelectionMode(mode: "selected" | "unselected" | "custom") {
    this.selectionMode = mode;
  }

  openOptionSection() {
    this.step = 'options'
  }

  // Returns true if option is selected
  isOptionSelected(optionId: number): boolean {
    if (!this.currentQuestion) return false;
    return this.currentQuestion.selectedOptionIds.includes(optionId);
  }

  // toggle funcitionality for checkboxes
  toggleOption(optionId: number, checked: boolean, event?: Event) {
    if (!this.currentQuestion) return;

   // only call stopPropagation if event is a real Event
  if (event instanceof Event) {
    event.stopPropagation();
  }

    const selected = this.currentQuestion.selectedOptionIds;

    if (checked) {
      // Add option if not already selected
      if (!selected.includes(optionId)) {
        selected.push(optionId);
      }
      // ensure operator exists
      if (!this.currentQuestion.optionOperators) {
        this.currentQuestion.optionOperators = {};
      }
      if (!this.currentQuestion.optionOperators[optionId]) {
        this.currentQuestion.optionOperators[optionId] = "or";
      }
    } else {
      // Remove option if selected
      const idx = selected.indexOf(optionId);
      if (idx > -1) {
        selected.splice(idx, 1);
      }
      // remove operator for this option
      if (this.currentQuestion.optionOperators) {
        delete this.currentQuestion.optionOperators[optionId];
      }
    }
  }

  // set question-level conditionType
  setConditionType(value: "if" | "or" | "and") {
    if (!this.currentQuestion) return;
    // For Qno===1, only 'if' is allowed — keep it enforced
    if (this.currentQuestion.Qno === 1) {
      this.currentQuestion.conditionType = "if";
      return;
    }
    this.currentQuestion.conditionType = value;
  }

  // set comparator (is, isnot, sum)
  setComparator(value: "is" | "isnot" | "sum") {
    if (!this.currentQuestion) return;
    this.currentQuestion.comparator = value;
  }

  // Returns operator for option or default 'or'
  getOptionOperator(optionId: number): "or" | "and" {
    if (!this.currentQuestion || !this.currentQuestion.optionOperators) {
      return "or";
    }
    return this.currentQuestion.optionOperators[optionId] || "or";
  }

  // set operator for individual option
  setOptionOperator(optionId: number, value: "or" | "and") {
    if (!this.currentQuestion) return;

    if (!this.currentQuestion.optionOperators) {
      this.currentQuestion.optionOperators = {};
    }
    this.currentQuestion.optionOperators[optionId] = value;
  }

  viewSelected() {
    if (!this.currentQuestion) return;
    // Only proceed if something was chosen
    if ((this.currentQuestion.selectedOptionIds || []).length === 0) return;

    this.currentQuestion.disabled = true;
    this.step = "review";
    this.currentQuestion = null;
  }

  getSelectedOptionTexts(
    question: QuestionsList
  ): { id: number; text: string; operator?: "or" | "and" }[] {
    // Use selectedOptionIds only and include operator
    return question.options
      .filter((o) => (question.selectedOptionIds || []).includes(o.id))
      .map((o) => ({
        id: o.id,
        text: o.option,
        operator: question.optionOperators
          ? question.optionOperators[o.id]
          : undefined,
      }));
  }

  // cancel options in options step
  cancelOptions() {
    if (this.currentQuestion) {
      // restore backup
      this.currentQuestion.selectedOptionIds = [...this.backupSelectedIds];

      // restore additional fields
      this.currentQuestion.conditionType = this.backupConditionType;
      this.currentQuestion.comparator = this.backupComparator;
      this.currentQuestion.optionOperators = {
        ...(this.backupOptionOperators || {}),
      };
    }
    this.step = "list";
    this.selectionMode = "selected";
    this.currentQuestion = null;
  }

  // show and hide making section
  hasMasking(): boolean {
    return this.questions.some((q) => (q.selectedOptionIds || []).length > 0);
  }
}
